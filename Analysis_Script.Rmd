---
title: "MSBT2 Cancer RNASeq Data Analysis"
author: "Kakembo Fredrick Elishama"
date: "9/10/2021"
output: pdf_document
---

# Loading the Packages
```{r loading packages, message=FALSE}
library(tidyverse)
library(DESeq2)
library(edgeR)
library(reshape2)
library(dendextend)
```


# Loading data

```{r import meta data, message=FALSE}
#setwd("~/Desktop/Academics/HackBio Fellowship/Transcriptomics/NeuroGenomics-HackBio/02-PracticalDiffExp/scripts/")
#setwd("~/Desktop/Kakembo/Cancer_RNASeq_DataAnalysis/")
setwd("~/Desktop/MSBT/Year2/Semester 1/Cancer Genetics and Genomics/Cancer_RNASeq_DataAnalysis/Cancer_RNASeq_DataAnalysis/")

list.files() #List files in the directory

#Reading the metadata file
meta <- read.csv("metadata.file1", sep="\t", row.names = 1, header = T, stringsAsFactors = T)
#meta <- read.csv("metadata.file", sep="\t")

levels(meta$cancer_type)

head(meta)
```


Next we want to read in the data. Each sample's counts are stored in a separate file. files into a count matrix

```{r import counts}
counts <- read.csv("hisat2/hisat2_counts.txt", sep="\t", header=T, row.names=1, comment.char = "#")
#head(counts)

#Check the column names
colnames(counts)

#Remove the unwanted columns
counts[c("Chr", "Start", "End", "Strand", "Length")] <- NULL

colnames(counts) <- gsub(".bam", "", colnames(counts))
colnames(counts) <- gsub("hisat2.", "", colnames(counts))

head(counts)

#Check if samples in the countdata matrix have a corresponding entry in the metadata file
all(rownames(meta) %in% colnames(counts))

#Check if the order of the samples in the matrix is similar to that in the metadata file.
all(colnames(counts) == rownames(meta))

#Since the order of the the counts file is not the same as that of the metadata file, 
# I rearrange the count data file to match the arrangement of the metadata file.
counts <- counts[, rownames(meta)]

#Check again
all(colnames(counts) == rownames(meta))


```



# Part 1: Breast Cancer vs Health Controls


```{r}
#Subset the medata to just breast cancer and Health controls
meta1 <- subset(meta,cancer_type=="Breast" | cancer_type=="HC" )

write.csv(meta1, "Metadata_BR_HC.file", sep = "\t")
meta1 <- read.csv("Metadata_BR_HC.file", row.names = 1, header = T, stringsAsFactors = T)

levels(meta1$cancer_type)
meta1$cancer_type <- relevel(meta1$cancer_type, ref = "HC")
meta1$cancer_type
#Subset the corresponing counts for the BC and HC
counts1 <- counts[, rownames(meta1)]

#Create the DESeq object
dds1<-DESeqDataSetFromMatrix(countData = counts1,
                            colData = meta1,
                            design = ~ cancer_type ) 

dds1<-DESeq(dds1)
```

```{r}
#Sample Dendogram
vsd <- vst(dds1, blind =FALSE)
mat <-assay(vsd)
head(as.data.frame(mat))


dend = t(mat) %>% 
  scale %>% 
  dist %>% 
  hclust %>% 
  as.dendrogram 

dend %>% 
  set("labels", meta1$cancer_type) %>% 
  plot
```


```{r}
mat.pca<-prcomp(t(mat)) #perform PCA
summary(mat.pca)

#Extract PCA scrores
scores <-as.data.frame(mat.pca$x) 
scores


# scores %>% 
#   mutate(GEO_Accession = rownames(scores)) %>% 
#   left_join(meta1) %>% 
#   ggplot(aes(PC1, PC2, color = cancer_type))+
#   geom_point()

```
## R Markdown



```{r}
res <- results(dds1)
summary(res)


vsd <- vst(dds1, blind=FALSE)  #computing for Variance Stabilizing Transformation
rld <- rlog(dds1, blind=FALSE) #Computing for regularised logarithm

#BiocManager::install("vsn")
#BiocManager::install("pheatmap")
#BiocManager::install("calibrate")
library(vsn)
library(pheatmap)
library("RColorBrewer")
require(genefilter)
require(calibrate)
#Dispersion Plots
#for the untransformed dds
ntd <- normTransform(dds1)
meanSdPlot(assay(ntd))
#for vst
meanSdPlot(assay(vsd))
#For rlog
meanSdPlot(assay(rld))


select <- order(rowMeans(counts(dds1,normalized=TRUE)), decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds1))
pheatmap(assay(vsd)[select,], cluster_rows=FALSE, show_rownames=FALSE,cluster_cols=FALSE, annotation_col=df)


#Calculate sample-2-sample distances
sampleDists <- dist(t(assay(vsd)))


sampleDistMatrix <- as.matrix(sampleDists) #Converting the dist object to matrix
rownames(sampleDistMatrix) <- vsd$Condition
colnames(sampleDistMatrix) <- rownames(meta1) 
#Defining the colors
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)

pheatmap(sampleDistMatrix, clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists, col=colors)


```


```{r}
#plotPCA(vsd, intgroup="Condition")

mycols <- brewer.pal(8, "Dark2")[1:length(unique(meta$Condition))]

rld_pca <- function (rld, intgroup = "Condition", ntop = 500, colors=NULL, legendpos="bottomleft", main="PCA Biplot", textcx=1, ...) {

require(RColorBrewer)
rv = rowVars(assay(rld))
select = order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]
pca = prcomp(t(assay(rld)[select, ]))
fac = factor(apply(as.data.frame(colData(rld)[, intgroup, drop = FALSE]), 1, paste, collapse = " : "))
if (is.null(colors)) {
if (nlevels(fac) >= 3) {
colors = brewer.pal(nlevels(fac), "Paired")
} else {
colors = c("black", "red")
}
}
pc1var <- round(summary(pca)$importance[2,1]*100, digits=1)
pc2var <- round(summary(pca)$importance[2,2]*100, digits=1)
pc1lab <- paste0("PC1 (",as.character(pc1var),"%)")
pc2lab <- paste0("PC1 (",as.character(pc2var),"%)")
plot(PC2~PC1, data=as.data.frame(pca$x), bg=colors[fac], pch=21, xlab=pc1lab, ylab=pc2lab, main=main, ...)
with(as.data.frame(pca$x), textxy(PC1, PC2, labs=rownames(as.data.frame(pca$x)), cex=textcx))
legend(legendpos, legend=levels(fac), col=colors, pch=20)
}
rld_pca(rld, colors=mycols, intgroup="cancer_type", xlim=c(-75, 35))

```

```{r}
#Dispersion plot
plotDispEsts(dds1, main="Dispersion plot for DESeq")
```

```{r}
#Obtain the coefficient to use for shrinkage
resultsNames(dds1)


#Computing for size shrikage using apeglm
resLFC <- lfcShrink(dds, coef="cancer_type_Breast_vs_HC", type="apeglm")
head(resLFC)

```



This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
